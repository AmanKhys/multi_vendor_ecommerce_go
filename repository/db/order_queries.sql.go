// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: order_queries.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const addOrder = `-- name: AddOrder :one
insert into orders
(user_id)
values ($1)
returning id, user_id, total_amount, coupon_id, discount_amount, net_amount, created_at, updated_at
`

func (q *Queries) AddOrder(ctx context.Context, userID uuid.UUID) (Order, error) {
	row := q.queryRow(ctx, q.addOrderStmt, addOrder, userID)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TotalAmount,
		&i.CouponID,
		&i.DiscountAmount,
		&i.NetAmount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const addOrderITem = `-- name: AddOrderITem :one
insert into order_items
(order_id, product_id, price, quantity)
values
($1, $2, $3, $4)
returning id, order_id, product_id, price, quantity, total_amount, status, created_at, updated_at
`

type AddOrderITemParams struct {
	OrderID   uuid.UUID `json:"order_id"`
	ProductID uuid.UUID `json:"product_id"`
	Price     float64   `json:"price"`
	Quantity  int32     `json:"quantity"`
}

func (q *Queries) AddOrderITem(ctx context.Context, arg AddOrderITemParams) (OrderItem, error) {
	row := q.queryRow(ctx, q.addOrderITemStmt, addOrderITem,
		arg.OrderID,
		arg.ProductID,
		arg.Price,
		arg.Quantity,
	)
	var i OrderItem
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.ProductID,
		&i.Price,
		&i.Quantity,
		&i.TotalAmount,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const addShippingAddress = `-- name: AddShippingAddress :one
insert into shipping_address
(order_id, house_name, street_name, town, district, state, pincode)
values
($1, $2, $3, $4, $5,$6, $7)
returning id, house_name, street_name, town, district, state, pincode
`

type AddShippingAddressParams struct {
	OrderID    uuid.UUID `json:"order_id"`
	HouseName  string    `json:"house_name"`
	StreetName string    `json:"street_name"`
	Town       string    `json:"town"`
	District   string    `json:"district"`
	State      string    `json:"state"`
	Pincode    int32     `json:"pincode"`
}

type AddShippingAddressRow struct {
	ID         uuid.UUID `json:"id"`
	HouseName  string    `json:"house_name"`
	StreetName string    `json:"street_name"`
	Town       string    `json:"town"`
	District   string    `json:"district"`
	State      string    `json:"state"`
	Pincode    int32     `json:"pincode"`
}

func (q *Queries) AddShippingAddress(ctx context.Context, arg AddShippingAddressParams) (AddShippingAddressRow, error) {
	row := q.queryRow(ctx, q.addShippingAddressStmt, addShippingAddress,
		arg.OrderID,
		arg.HouseName,
		arg.StreetName,
		arg.Town,
		arg.District,
		arg.State,
		arg.Pincode,
	)
	var i AddShippingAddressRow
	err := row.Scan(
		&i.ID,
		&i.HouseName,
		&i.StreetName,
		&i.Town,
		&i.District,
		&i.State,
		&i.Pincode,
	)
	return i, err
}

const cancelOrderByID = `-- name: CancelOrderByID :many
update order_items
set status = 'cancelled', updated_at = current_timestamp
where order_id = $1
returning id, order_id, product_id, price, quantity, total_amount, status, created_at, updated_at
`

func (q *Queries) CancelOrderByID(ctx context.Context, orderID uuid.UUID) ([]OrderItem, error) {
	rows, err := q.query(ctx, q.cancelOrderByIDStmt, cancelOrderByID, orderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []OrderItem{}
	for rows.Next() {
		var i OrderItem
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.ProductID,
			&i.Price,
			&i.Quantity,
			&i.TotalAmount,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const changeOrderItemStatusByID = `-- name: ChangeOrderItemStatusByID :one
update order_items oi
set status =  $2
where id = $1
returning id, order_id, product_id, price, quantity, total_amount, status, created_at, updated_at
`

type ChangeOrderItemStatusByIDParams struct {
	ID     uuid.UUID `json:"id"`
	Status string    `json:"status"`
}

func (q *Queries) ChangeOrderItemStatusByID(ctx context.Context, arg ChangeOrderItemStatusByIDParams) (OrderItem, error) {
	row := q.queryRow(ctx, q.changeOrderItemStatusByIDStmt, changeOrderItemStatusByID, arg.ID, arg.Status)
	var i OrderItem
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.ProductID,
		&i.Price,
		&i.Quantity,
		&i.TotalAmount,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteOrderByID = `-- name: DeleteOrderByID :exec
delete from orders
where id = $1
`

func (q *Queries) DeleteOrderByID(ctx context.Context, id uuid.UUID) error {
	_, err := q.exec(ctx, q.deleteOrderByIDStmt, deleteOrderByID, id)
	return err
}

const editOrderAmountByID = `-- name: EditOrderAmountByID :one
update orders
set total_amount = $1, discount_amount = $2, coupon_id = $3, updated_at = current_timestamp
where id = $4
returning id, user_id, total_amount, coupon_id, discount_amount, net_amount, created_at, updated_at
`

type EditOrderAmountByIDParams struct {
	TotalAmount    float64       `json:"total_amount"`
	DiscountAmount float64       `json:"discount_amount"`
	CouponID       uuid.NullUUID `json:"coupon_id"`
	ID             uuid.UUID     `json:"id"`
}

func (q *Queries) EditOrderAmountByID(ctx context.Context, arg EditOrderAmountByIDParams) (Order, error) {
	row := q.queryRow(ctx, q.editOrderAmountByIDStmt, editOrderAmountByID,
		arg.TotalAmount,
		arg.DiscountAmount,
		arg.CouponID,
		arg.ID,
	)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TotalAmount,
		&i.CouponID,
		&i.DiscountAmount,
		&i.NetAmount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const editOrderItemStatusByID = `-- name: EditOrderItemStatusByID :one
update order_items
set status = $2, updated_at = current_timestamp
where id = $1
returning id, order_id, product_id, price, quantity, total_amount, status, created_at, updated_at
`

type EditOrderItemStatusByIDParams struct {
	ID     uuid.UUID `json:"id"`
	Status string    `json:"status"`
}

func (q *Queries) EditOrderItemStatusByID(ctx context.Context, arg EditOrderItemStatusByIDParams) (OrderItem, error) {
	row := q.queryRow(ctx, q.editOrderItemStatusByIDStmt, editOrderItemStatusByID, arg.ID, arg.Status)
	var i OrderItem
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.ProductID,
		&i.Price,
		&i.Quantity,
		&i.TotalAmount,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAllOrderItemsForAdmin = `-- name: GetAllOrderItemsForAdmin :many
select id, order_id, product_id, price, quantity, total_amount, status, created_at, updated_at from order_items
order by created_at desc
`

func (q *Queries) GetAllOrderItemsForAdmin(ctx context.Context) ([]OrderItem, error) {
	rows, err := q.query(ctx, q.getAllOrderItemsForAdminStmt, getAllOrderItemsForAdmin)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []OrderItem{}
	for rows.Next() {
		var i OrderItem
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.ProductID,
			&i.Price,
			&i.Quantity,
			&i.TotalAmount,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllOrders = `-- name: GetAllOrders :many
select id, user_id, total_amount, coupon_id, discount_amount, net_amount, created_at, updated_at from orders
`

func (q *Queries) GetAllOrders(ctx context.Context) ([]Order, error) {
	rows, err := q.query(ctx, q.getAllOrdersStmt, getAllOrders)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Order{}
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.TotalAmount,
			&i.CouponID,
			&i.DiscountAmount,
			&i.NetAmount,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrderByID = `-- name: GetOrderByID :one
select id, user_id, total_amount, coupon_id, discount_amount, net_amount, created_at, updated_at from orders
where id = $1
`

func (q *Queries) GetOrderByID(ctx context.Context, id uuid.UUID) (Order, error) {
	row := q.queryRow(ctx, q.getOrderByIDStmt, getOrderByID, id)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TotalAmount,
		&i.CouponID,
		&i.DiscountAmount,
		&i.NetAmount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getOrderItemByID = `-- name: GetOrderItemByID :one
select id, order_id, product_id, price, quantity, total_amount, status, created_at, updated_at from order_items
where id = $1
`

func (q *Queries) GetOrderItemByID(ctx context.Context, id uuid.UUID) (OrderItem, error) {
	row := q.queryRow(ctx, q.getOrderItemByIDStmt, getOrderItemByID, id)
	var i OrderItem
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.ProductID,
		&i.Price,
		&i.Quantity,
		&i.TotalAmount,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getOrderItemByUserAndProductID = `-- name: GetOrderItemByUserAndProductID :one
select oi.id, oi.order_id, oi.product_id, oi.price, oi.quantity, oi.total_amount, oi.status, oi.created_at, oi.updated_at
from order_items oi
inner join orders o
on oi.order_id = o.id
where oi.product_id = $1 and 
o.user_id = $2 and
(oi.status = 'delivered' or oi.status = 'returned')
limit 1
`

type GetOrderItemByUserAndProductIDParams struct {
	ProductID uuid.UUID `json:"product_id"`
	UserID    uuid.UUID `json:"user_id"`
}

func (q *Queries) GetOrderItemByUserAndProductID(ctx context.Context, arg GetOrderItemByUserAndProductIDParams) (OrderItem, error) {
	row := q.queryRow(ctx, q.getOrderItemByUserAndProductIDStmt, getOrderItemByUserAndProductID, arg.ProductID, arg.UserID)
	var i OrderItem
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.ProductID,
		&i.Price,
		&i.Quantity,
		&i.TotalAmount,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getOrderItemsByOrderID = `-- name: GetOrderItemsByOrderID :many
select oi.id, oi.order_id, oi.product_id, oi.price, oi.quantity, oi.total_amount, oi.status, oi.created_at, oi.updated_at, p.name as product_name
from order_items oi
inner join products p
on oi.product_id = p.id
where oi.order_id = $1
`

type GetOrderItemsByOrderIDRow struct {
	ID          uuid.UUID `json:"id"`
	OrderID     uuid.UUID `json:"order_id"`
	ProductID   uuid.UUID `json:"product_id"`
	Price       float64   `json:"price"`
	Quantity    int32     `json:"quantity"`
	TotalAmount float64   `json:"total_amount"`
	Status      string    `json:"status"`
	CreatedAt   time.Time `json:"created_at"`
	UpdatedAt   time.Time `json:"updated_at"`
	ProductName string    `json:"product_name"`
}

func (q *Queries) GetOrderItemsByOrderID(ctx context.Context, orderID uuid.UUID) ([]GetOrderItemsByOrderIDRow, error) {
	rows, err := q.query(ctx, q.getOrderItemsByOrderIDStmt, getOrderItemsByOrderID, orderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetOrderItemsByOrderIDRow{}
	for rows.Next() {
		var i GetOrderItemsByOrderIDRow
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.ProductID,
			&i.Price,
			&i.Quantity,
			&i.TotalAmount,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProductName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrderItemsBySellerID = `-- name: GetOrderItemsBySellerID :many
select oi.id, oi.order_id, oi.product_id, oi.price, oi.quantity, oi.total_amount, oi.status, oi.created_at, oi.updated_at from order_items oi
inner join products p
on oi.product_id = p.id
where p.seller_id = $1
order by oi.created_at desc
`

func (q *Queries) GetOrderItemsBySellerID(ctx context.Context, sellerID uuid.UUID) ([]OrderItem, error) {
	rows, err := q.query(ctx, q.getOrderItemsBySellerIDStmt, getOrderItemsBySellerID, sellerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []OrderItem{}
	for rows.Next() {
		var i OrderItem
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.ProductID,
			&i.Price,
			&i.Quantity,
			&i.TotalAmount,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrderItemsBySellerIDAndDateRange = `-- name: GetOrderItemsBySellerIDAndDateRange :many
select oi.id, oi.order_id, oi.product_id, oi.price, oi.quantity, oi.total_amount, oi.status, oi.created_at, oi.updated_at 
from order_items oi
inner join products p on oi.product_id = p.id
where p.seller_id = $1 
  and oi.created_at between $2 and $3
order by oi.created_at desc
`

type GetOrderItemsBySellerIDAndDateRangeParams struct {
	SellerID  uuid.UUID `json:"seller_id"`
	StartDate time.Time `json:"start_date"`
	EndDate   time.Time `json:"end_date"`
}

func (q *Queries) GetOrderItemsBySellerIDAndDateRange(ctx context.Context, arg GetOrderItemsBySellerIDAndDateRangeParams) ([]OrderItem, error) {
	rows, err := q.query(ctx, q.getOrderItemsBySellerIDAndDateRangeStmt, getOrderItemsBySellerIDAndDateRange, arg.SellerID, arg.StartDate, arg.EndDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []OrderItem{}
	for rows.Next() {
		var i OrderItem
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.ProductID,
			&i.Price,
			&i.Quantity,
			&i.TotalAmount,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrderItemsByUserID = `-- name: GetOrderItemsByUserID :many
select oi.id, oi.order_id, oi.product_id, oi.price, oi.quantity, oi.total_amount, oi.status, oi.created_at, oi.updated_at from order_items oi
inner join orders o
on oi.order_id = o.id
inner join users u
on o.user_id = u.id
where u.id = $1
order by oi.created_at desc
`

func (q *Queries) GetOrderItemsByUserID(ctx context.Context, id uuid.UUID) ([]OrderItem, error) {
	rows, err := q.query(ctx, q.getOrderItemsByUserIDStmt, getOrderItemsByUserID, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []OrderItem{}
	for rows.Next() {
		var i OrderItem
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.ProductID,
			&i.Price,
			&i.Quantity,
			&i.TotalAmount,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrdersByUserID = `-- name: GetOrdersByUserID :many
select id, user_id, total_amount, coupon_id, discount_amount, net_amount, created_at, updated_at from orders
where user_id = $1
order by created_at desc
`

func (q *Queries) GetOrdersByUserID(ctx context.Context, userID uuid.UUID) ([]Order, error) {
	rows, err := q.query(ctx, q.getOrdersByUserIDStmt, getOrdersByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Order{}
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.TotalAmount,
			&i.CouponID,
			&i.DiscountAmount,
			&i.NetAmount,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReviewByUserAndProductID = `-- name: GetReviewByUserAndProductID :one
select id, user_id, product_id, rating, comment, is_deleted, is_edited, created_at, updated_at
from reviews r
where r.user_id = $1 and r.product_id = $2
`

type GetReviewByUserAndProductIDParams struct {
	UserID    uuid.UUID `json:"user_id"`
	ProductID uuid.UUID `json:"product_id"`
}

func (q *Queries) GetReviewByUserAndProductID(ctx context.Context, arg GetReviewByUserAndProductIDParams) (Review, error) {
	row := q.queryRow(ctx, q.getReviewByUserAndProductIDStmt, getReviewByUserAndProductID, arg.UserID, arg.ProductID)
	var i Review
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ProductID,
		&i.Rating,
		&i.Comment,
		&i.IsDeleted,
		&i.IsEdited,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSellerIDFromOrderItemID = `-- name: GetSellerIDFromOrderItemID :one
select p.seller_id from order_items oi
inner join products p
on oi.product_id = p.id
where oi.id = $1
`

func (q *Queries) GetSellerIDFromOrderItemID(ctx context.Context, id uuid.UUID) (uuid.UUID, error) {
	row := q.queryRow(ctx, q.getSellerIDFromOrderItemIDStmt, getSellerIDFromOrderItemID, id)
	var seller_id uuid.UUID
	err := row.Scan(&seller_id)
	return seller_id, err
}

const getTotalAmountOfCartItems = `-- name: GetTotalAmountOfCartItems :one
select sum(total_amount) as total_amount
from carts
where user_id = $1
`

func (q *Queries) GetTotalAmountOfCartItems(ctx context.Context, userID uuid.UUID) (int64, error) {
	row := q.queryRow(ctx, q.getTotalAmountOfCartItemsStmt, getTotalAmountOfCartItems, userID)
	var total_amount int64
	err := row.Scan(&total_amount)
	return total_amount, err
}

const getUserIDFromOrderItemID = `-- name: GetUserIDFromOrderItemID :one
select u.id from order_items oi
inner join orders o
on oi.order_id = o.id
inner join users u
on o.user_id = u.id
where oi.id = $1
`

func (q *Queries) GetUserIDFromOrderItemID(ctx context.Context, id uuid.UUID) (uuid.UUID, error) {
	row := q.queryRow(ctx, q.getUserIDFromOrderItemIDStmt, getUserIDFromOrderItemID, id)
	err := row.Scan(&id)
	return id, err
}

const updateOrderTotalAmount = `-- name: UpdateOrderTotalAmount :one
update orders
set total_amount = $1, updated_at = current_timestamp
where id = $2
returning id, user_id, total_amount, coupon_id, discount_amount, net_amount, created_at, updated_at
`

type UpdateOrderTotalAmountParams struct {
	TotalAmount float64   `json:"total_amount"`
	ID          uuid.UUID `json:"id"`
}

func (q *Queries) UpdateOrderTotalAmount(ctx context.Context, arg UpdateOrderTotalAmountParams) (Order, error) {
	row := q.queryRow(ctx, q.updateOrderTotalAmountStmt, updateOrderTotalAmount, arg.TotalAmount, arg.ID)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TotalAmount,
		&i.CouponID,
		&i.DiscountAmount,
		&i.NetAmount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
